class Ghost{constructor(scaledTileSize,mazeArray,pacman,name,level,characterUtil,blinky){this.scaledTileSize=scaledTileSize,this.mazeArray=mazeArray,this.pacman=pacman,this.name=name,this.level=level,this.characterUtil=characterUtil,this.blinky=blinky,this.animationTarget=document.getElementById(name),this.reset()}reset(fullGameReset){fullGameReset&&(delete this.defaultSpeed,delete this.cruiseElroy),this.setDefaultMode(),this.setMovementStats(this.pacman,this.name,this.level),this.setSpriteAnimationStats(),this.setStyleMeasurements(this.scaledTileSize,this.spriteFrames),this.setDefaultPosition(this.scaledTileSize,this.name),this.setSpriteSheet(this.name,this.direction,this.mode)}setDefaultMode(){this.allowCollision=!0,this.defaultMode="scatter",this.mode="scatter","blinky"!==this.name&&(this.idleMode="idle")}setMovementStats(pacman,name,level){const pacmanSpeed=pacman.velocityPerMs,levelAdjustment=level/100;switch(this.slowSpeed=pacmanSpeed*(.75+levelAdjustment),this.mediumSpeed=pacmanSpeed*(.875+levelAdjustment),this.fastSpeed=pacmanSpeed*(1+levelAdjustment),this.defaultSpeed||(this.defaultSpeed=this.slowSpeed),this.scaredSpeed=.5*pacmanSpeed,this.transitionSpeed=.4*pacmanSpeed,this.eyeSpeed=2*pacmanSpeed,this.velocityPerMs=this.defaultSpeed,this.moving=!1,name){case"blinky":this.defaultDirection=this.characterUtil.directions.left;break;case"pinky":this.defaultDirection=this.characterUtil.directions.down;break;case"inky":case"clyde":this.defaultDirection=this.characterUtil.directions.up;break;default:this.defaultDirection=this.characterUtil.directions.left}this.direction=this.defaultDirection}setSpriteAnimationStats(){this.display=!0,this.loopAnimation=!0,this.animate=!0,this.msBetweenSprites=250,this.msSinceLastSprite=0,this.spriteFrames=2,this.backgroundOffsetPixels=0,this.animationTarget.style.backgroundPosition="0px 0px"}setStyleMeasurements(scaledTileSize,spriteFrames){this.measurement=2*scaledTileSize,this.animationTarget.style.height=`${this.measurement}px`,this.animationTarget.style.width=`${this.measurement}px`;const bgSize=this.measurement*spriteFrames;this.animationTarget.style.backgroundSize=`${bgSize}px`}setDefaultPosition(scaledTileSize,name){switch(name){case"blinky":this.defaultPosition={top:10.5*scaledTileSize,left:13*scaledTileSize};break;case"pinky":this.defaultPosition={top:13.5*scaledTileSize,left:13*scaledTileSize};break;case"inky":this.defaultPosition={top:13.5*scaledTileSize,left:11*scaledTileSize};break;case"clyde":this.defaultPosition={top:13.5*scaledTileSize,left:15*scaledTileSize};break;default:this.defaultPosition={top:0,left:0}}this.position=Object.assign({},this.defaultPosition),this.oldPosition=Object.assign({},this.position),this.animationTarget.style.top=`${this.position.top}px`,this.animationTarget.style.left=`${this.position.left}px`}setSpriteSheet(name,direction,mode){let emotion="";this.defaultSpeed!==this.slowSpeed&&(emotion=this.defaultSpeed===this.mediumSpeed?"_annoyed":"_angry"),this.animationTarget.style.backgroundImage="scared"===mode?"url(app/style/graphics/"+`spriteSheets/characters/ghosts/branded/scared_${this.scaredColor}.svg)`:"eyes"===mode?"url(app/style/graphics/"+`spriteSheets/characters/ghosts/branded/eyes_${direction}.svg)`:"url(app/style/graphics/"+`spriteSheets/characters/ghosts/branded/${name}/${name}_${direction}`+`${emotion}.svg)`}isInTunnel(gridPosition){return 14===gridPosition.y&&(gridPosition.x<6||gridPosition.x>21)}isInGhostHouse(gridPosition){return gridPosition.x>9&&gridPosition.x<18&&gridPosition.y>11&&gridPosition.y<17}getTile(mazeArray,y,x){let tile=!1;return mazeArray[y]&&mazeArray[y][x]&&"X"!==mazeArray[y][x]&&(tile={x:x,y:y}),tile}determinePossibleMoves(gridPosition,direction,mazeArray){const{x:x,y:y}=gridPosition,possibleMoves={up:this.getTile(mazeArray,y-1,x),down:this.getTile(mazeArray,y+1,x),left:this.getTile(mazeArray,y,x-1),right:this.getTile(mazeArray,y,x+1)};return possibleMoves[this.characterUtil.getOppositeDirection(direction)]=!1,Object.keys(possibleMoves).forEach(tile=>{!1===possibleMoves[tile]&&delete possibleMoves[tile]}),possibleMoves}calculateDistance(position,pacman){return Math.sqrt((position.x-pacman.x)**2+(position.y-pacman.y)**2)}getPositionInFrontOfPacman(pacmanGridPosition,spaces){const target=Object.assign({},pacmanGridPosition),pacDirection=this.pacman.direction,propToChange="up"===pacDirection||"down"===pacDirection?"y":"x",tileOffset="up"===pacDirection||"left"===pacDirection?-1*spaces:spaces;return target[propToChange]+=tileOffset,target}determinePinkyTarget(pacmanGridPosition){return this.getPositionInFrontOfPacman(pacmanGridPosition,4)}determineInkyTarget(pacmanGridPosition){const blinkyGridPosition=this.characterUtil.determineGridPosition(this.blinky.position,this.scaledTileSize),pivotPoint=this.getPositionInFrontOfPacman(pacmanGridPosition,2);return{x:pivotPoint.x+(pivotPoint.x-blinkyGridPosition.x),y:pivotPoint.y+(pivotPoint.y-blinkyGridPosition.y)}}determineClydeTarget(gridPosition,pacmanGridPosition){const distance=this.calculateDistance(gridPosition,pacmanGridPosition);return distance>8?pacmanGridPosition:{x:0,y:30}}getTarget(name,gridPosition,pacmanGridPosition,mode){if("eyes"===mode)return{x:13.5,y:10};if("scared"===mode)return pacmanGridPosition;if("scatter"===mode)switch(name){case"blinky":return this.cruiseElroy?pacmanGridPosition:{x:27,y:0};case"pinky":return{x:0,y:0};case"inky":return{x:27,y:30};case"clyde":return{x:0,y:30};default:return{x:0,y:0}}switch(name){case"blinky":return pacmanGridPosition;case"pinky":return this.determinePinkyTarget(pacmanGridPosition);case"inky":return this.determineInkyTarget(pacmanGridPosition);case"clyde":return this.determineClydeTarget(gridPosition,pacmanGridPosition);default:return pacmanGridPosition}}determineBestMove(name,possibleMoves,gridPosition,pacmanGridPosition,mode){let bestDistance="scared"===mode?0:1/0,bestMove;const target=this.getTarget(name,gridPosition,pacmanGridPosition,mode);return Object.keys(possibleMoves).forEach(move=>{const distance=this.calculateDistance(possibleMoves[move],target),betterMove="scared"===mode?distance>bestDistance:distance<bestDistance;betterMove&&(bestDistance=distance,bestMove=move)}),bestMove}determineDirection(name,gridPosition,pacmanGridPosition,direction,mazeArray,mode){let newDirection=direction;const possibleMoves=this.determinePossibleMoves(gridPosition,direction,mazeArray);return 1===Object.keys(possibleMoves).length?[newDirection]=Object.keys(possibleMoves):Object.keys(possibleMoves).length>1&&(newDirection=this.determineBestMove(name,possibleMoves,gridPosition,pacmanGridPosition,mode)),newDirection}handleIdleMovement(elapsedMs,position,velocity){const newPosition=Object.assign({},this.position);return position.y<=13.5?this.direction=this.characterUtil.directions.down:position.y>=14.5&&(this.direction=this.characterUtil.directions.up),"leaving"===this.idleMode&&(13.5===position.x&&position.y>10.8&&position.y<11?(this.idleMode=void 0,newPosition.top=10.5*this.scaledTileSize,this.direction=this.characterUtil.directions.left,window.dispatchEvent(new Event("releaseGhost"))):position.x>13.4&&position.x<13.6?(newPosition.left=13*this.scaledTileSize,this.direction=this.characterUtil.directions.up):position.y>13.9&&position.y<14.1&&(newPosition.top=13.5*this.scaledTileSize,this.direction=position.x<13.5?this.characterUtil.directions.right:this.characterUtil.directions.left)),newPosition[this.characterUtil.getPropertyToChange(this.direction)]+=this.characterUtil.getVelocity(this.direction,velocity)*elapsedMs,newPosition}endIdleMode(){this.idleMode="leaving"}handleSnappedMovement(elapsedMs,gridPosition,velocity,pacmanGridPosition){const newPosition=Object.assign({},this.position);return this.direction=this.determineDirection(this.name,gridPosition,pacmanGridPosition,this.direction,this.mazeArray,this.mode),newPosition[this.characterUtil.getPropertyToChange(this.direction)]+=this.characterUtil.getVelocity(this.direction,velocity)*elapsedMs,newPosition}enteringGhostHouse(mode,position){return"eyes"===mode&&11===position.y&&position.x>13.4&&position.x<13.6}enteredGhostHouse(mode,position){return"eyes"===mode&&13.5===position.x&&position.y>13.8&&position.y<14.2}leavingGhostHouse(mode,position){return"eyes"!==mode&&13.5===position.x&&position.y>10.8&&position.y<11}handleGhostHouse(gridPosition){const gridPositionCopy=Object.assign({},gridPosition);return this.enteringGhostHouse(this.mode,gridPosition)&&(this.direction=this.characterUtil.directions.down,gridPositionCopy.x=13.5,this.position=this.characterUtil.snapToGrid(gridPositionCopy,this.direction,this.scaledTileSize)),this.enteredGhostHouse(this.mode,gridPosition)&&(this.direction=this.characterUtil.directions.up,gridPositionCopy.y=14,this.position=this.characterUtil.snapToGrid(gridPositionCopy,this.direction,this.scaledTileSize),this.mode=this.defaultMode,window.dispatchEvent(new Event("restoreGhost"))),this.leavingGhostHouse(this.mode,gridPosition)&&(gridPositionCopy.y=11,this.position=this.characterUtil.snapToGrid(gridPositionCopy,this.direction,this.scaledTileSize),this.direction=this.characterUtil.directions.left),gridPositionCopy}handleUnsnappedMovement(elapsedMs,gridPosition,velocity){const gridPositionCopy=this.handleGhostHouse(gridPosition),desired=this.characterUtil.determineNewPositions(this.position,this.direction,velocity,elapsedMs,this.scaledTileSize);return this.characterUtil.changingGridPosition(gridPositionCopy,desired.newGridPosition)?this.characterUtil.snapToGrid(gridPositionCopy,this.direction,this.scaledTileSize):desired.newPosition}handleMovement(elapsedMs){let newPosition;const gridPosition=this.characterUtil.determineGridPosition(this.position,this.scaledTileSize),pacmanGridPosition=this.characterUtil.determineGridPosition(this.pacman.position,this.scaledTileSize),velocity=this.determineVelocity(gridPosition,this.mode);return newPosition=this.idleMode?this.handleIdleMovement(elapsedMs,gridPosition,velocity):JSON.stringify(this.position)===JSON.stringify(this.characterUtil.snapToGrid(gridPosition,this.direction,this.scaledTileSize))?this.handleSnappedMovement(elapsedMs,gridPosition,velocity,pacmanGridPosition):this.handleUnsnappedMovement(elapsedMs,gridPosition,velocity),newPosition=this.characterUtil.handleWarp(newPosition,this.scaledTileSize,this.mazeArray),this.checkCollision(gridPosition,pacmanGridPosition),newPosition}changeMode(newMode){this.defaultMode=newMode;const gridPosition=this.characterUtil.determineGridPosition(this.position,this.scaledTileSize);"chase"!==this.mode&&"scatter"!==this.mode||this.cruiseElroy||(this.mode=newMode,this.isInGhostHouse(gridPosition)||(this.direction=this.characterUtil.getOppositeDirection(this.direction)))}toggleScaredColor(){this.scaredColor="blue"===this.scaredColor?"white":"blue",this.setSpriteSheet(this.name,this.direction,this.mode)}becomeScared(){const gridPosition=this.characterUtil.determineGridPosition(this.position,this.scaledTileSize);"eyes"!==this.mode&&(this.isInGhostHouse(gridPosition)||"scared"===this.mode||(this.direction=this.characterUtil.getOppositeDirection(this.direction)),this.mode="scared",this.scaredColor="blue",this.setSpriteSheet(this.name,this.direction,this.mode))}endScared(){this.mode=this.defaultMode,this.setSpriteSheet(this.name,this.direction,this.mode)}speedUp(){this.cruiseElroy=!0,this.defaultSpeed===this.slowSpeed?this.defaultSpeed=this.mediumSpeed:this.defaultSpeed===this.mediumSpeed&&(this.defaultSpeed=this.fastSpeed)}resetDefaultSpeed(){this.defaultSpeed=this.slowSpeed,this.cruiseElroy=!1,this.setSpriteSheet(this.name,this.direction,this.mode)}pause(newValue){this.paused=newValue}checkCollision(position,pacman){this.calculateDistance(position,pacman)<1&&"eyes"!==this.mode&&this.allowCollision&&("scared"===this.mode?(window.dispatchEvent(new CustomEvent("eatGhost",{detail:{ghost:this}})),this.mode="eyes"):window.dispatchEvent(new Event("deathSequence")))}determineVelocity(position,mode){return"eyes"===mode?this.eyeSpeed:this.paused?0:this.isInTunnel(position)||this.isInGhostHouse(position)?this.transitionSpeed:"scared"===mode?this.scaredSpeed:this.defaultSpeed}draw(interp){const newTop=this.characterUtil.calculateNewDrawValue(interp,"top",this.oldPosition,this.position),newLeft=this.characterUtil.calculateNewDrawValue(interp,"left",this.oldPosition,this.position);this.animationTarget.style.top=`${newTop}px`,this.animationTarget.style.left=`${newLeft}px`,this.animationTarget.style.visibility=this.display?this.characterUtil.checkForStutter(this.position,this.oldPosition):"hidden";const updatedProperties=this.characterUtil.advanceSpriteSheet(this);this.msSinceLastSprite=updatedProperties.msSinceLastSprite,this.animationTarget=updatedProperties.animationTarget,this.backgroundOffsetPixels=updatedProperties.backgroundOffsetPixels}update(elapsedMs){this.oldPosition=Object.assign({},this.position),this.moving&&(this.position=this.handleMovement(elapsedMs),this.setSpriteSheet(this.name,this.direction,this.mode),this.msSinceLastSprite+=elapsedMs)}}module.exports=Ghost;
//# sourceMappingURL=ghost.min.js.map